// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<VirtualDisplayDriver>>
@sealed
class VirtualDisplayDriver extends RustOpaque {
  VirtualDisplayDriver.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  VirtualDisplayDriver.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VirtualDisplayDriver,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VirtualDisplayDriver,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VirtualDisplayDriverPtr,
  );

  /// Add a new monitor to the driver.
  void addMonitor(
          {String? name,
          required bool enabled,
          required List<Mode> modes,
          dynamic hint}) =>
      RustLib.instance.api.virtualDisplayDriverAddMonitor(
          that: this, name: name, enabled: enabled, modes: modes, hint: hint);

  /// Cancel any previously set up stream
  Future<void> cancelStream({dynamic hint}) => RustLib.instance.api
      .virtualDisplayDriverCancelStream(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<VirtualDisplayDriver> newInstance(
          {String? pipeName, dynamic hint}) =>
      RustLib.instance.api
          .virtualDisplayDriverNew(pipeName: pipeName, hint: hint);

  /// Push in-memory changes to driver.
  Future<void> notify({dynamic hint}) =>
      RustLib.instance.api.virtualDisplayDriverNotify(that: this, hint: hint);

  /// Persist in-memory changes to user settings
  Future<void> persist({dynamic hint}) =>
      RustLib.instance.api.virtualDisplayDriverPersist(that: this, hint: hint);

  /// Remove all monitors from the driver.
  void removeAllMonitors({dynamic hint}) => RustLib.instance.api
      .virtualDisplayDriverRemoveAllMonitors(that: this, hint: hint);

  /// Remove monitors from the driver.
  void removeMonitors({required List<int> ids, dynamic hint}) =>
      RustLib.instance.api
          .virtualDisplayDriverRemoveMonitors(that: this, ids: ids, hint: hint);

  /// Set the state of the monitor with the provided ID.
  ///
  /// Only the provided properties will be updated.
  void setMonitor(
          {required int id,
          bool? enabled,
          String? name,
          List<Mode>? modes,
          dynamic hint}) =>
      RustLib.instance.api.virtualDisplayDriverSetMonitor(
          that: this,
          id: id,
          enabled: enabled,
          name: name,
          modes: modes,
          hint: hint);

  /// Set the state of the provided monitors.
  ///
  /// Each monitor with a matching ID will be updated to the provided state.
  void setMonitors({required List<Monitor> monitors, dynamic hint}) =>
      RustLib.instance.api.virtualDisplayDriverSetMonitors(
          that: this, monitors: monitors, hint: hint);

  /// Get the current state of the driver.
  List<Monitor> get state => RustLib.instance.api.virtualDisplayDriverState(
        that: this,
      );

  /// Stream of state changes.
  ///
  /// Updates whenever the state of the driver changes. It does not matter
  /// from which process the change is requested. It will always reflect the
  /// current state of the driver.
  ///
  /// If set again, it will cancel the old stream and set the new one
  Future<Stream<List<Monitor>>> get stream =>
      RustLib.instance.api.virtualDisplayDriverStream(
        that: this,
      );
}

@freezed
sealed class IpcError with _$IpcError implements FrbException {
  const IpcError._();

  const factory IpcError.serDe(
    String field0,
  ) = IpcError_SerDe;
  const factory IpcError.io(
    String field0,
  ) = IpcError_Io;
  const factory IpcError.win(
    String field0,
  ) = IpcError_Win;
  const factory IpcError.client(
    String field0,
  ) = IpcError_Client;
  const factory IpcError.requestState() = IpcError_RequestState;
  const factory IpcError.receive() = IpcError_Receive;
  const factory IpcError.connectionFailed(
    String field0,
  ) = IpcError_ConnectionFailed;
  const factory IpcError.sendFailed() = IpcError_SendFailed;
}

@freezed
class Mode with _$Mode {
  const factory Mode({
    required int width,
    required int height,
    required Uint32List refreshRates,
  }) = _Mode;
}

@freezed
class Monitor with _$Monitor {
  const factory Monitor({
    required int id,
    String? name,
    required bool enabled,
    required List<Mode> modes,
  }) = _Monitor;
}
