// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'client.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  /// Connect to the driver.
  ///
  /// You can optionally specify the name of the named pipe to connect to. The
  /// default value is "virtualdisplaydriver".
  static Future<Client> connect({String? pipeName}) =>
      RustLib.instance.api.crateApiClientClientConnect(pipeName: pipeName);

  /// Send new state to the driver.
  Future<void> notify({required List<Monitor> monitors});

  /// Write `monitors` to the registry for current user.
  ///
  /// Next time the driver is started, it will load this state from the
  /// registry. This might be after a reboot or a driver restart.
  static Future<void> persist({required List<Monitor> monitors}) =>
      RustLib.instance.api.crateApiClientClientPersist(monitors: monitors);

  /// Receive continuous events from the driver.
  ///
  /// Only new events after calling this method are received.
  ///
  /// May be called multiple times.
  Stream<List<Monitor>> receiveEvents();

  /// Remove all monitors with the specified IDs.
  Future<void> remove({required List<int> ids});

  /// Remove all monitors.
  Future<void> removeAll();

  /// Request the current state of the driver.
  ///
  /// Throws [RequestError.timeout] if the driver does not respond within 5
  /// seconds.
  Future<List<Monitor>> requestState();
}

@freezed
sealed class ConnectionError with _$ConnectionError implements FrbException {
  const ConnectionError._();

  const factory ConnectionError.failed({
    required String message,
  }) = ConnectionError_Failed;

  @override
  String toString() => switch (this) {
        ConnectionError_Failed(:final message) =>
          'Failed to open pipe: $message',
      };
}

@freezed
sealed class PersistError with _$PersistError implements FrbException {
  const PersistError._();

  const factory PersistError.open({
    required String message,
  }) = PersistError_Open;
  const factory PersistError.set_({
    required String message,
  }) = PersistError_Set;
  const factory PersistError.serialize({
    required String message,
  }) = PersistError_Serialize;

  @override
  String toString() => switch (this) {
        PersistError_Open(:final message) =>
          'Failed to open registry key: $message',
        PersistError_Set(:final message) =>
          'Failed to set registry key: $message',
        PersistError_Serialize(:final message) =>
          'Failed to serialize data: $message',
      };
}

class ReceiveError implements FrbException {
  final String message;

  const ReceiveError({
    required this.message,
  });

  @override
  String toString() => switch (this) {
        ReceiveError(:final message) => 'Failed to receive event: $message',
      };

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceiveError &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

@freezed
sealed class RequestError with _$RequestError implements FrbException {
  const RequestError._();

  const factory RequestError.send({
    required String message,
  }) = RequestError_Send;
  const factory RequestError.receive({
    required String message,
  }) = RequestError_Receive;
  const factory RequestError.timeout({
    required Duration duration,
  }) = RequestError_Timeout;

  @override
  String toString() => switch (this) {
        RequestError_Send(:final message) =>
          'Failed to send message (pipe broken): $message',
        RequestError_Receive(:final message) =>
          'Failed to receive message (pipe broken): $message',
        RequestError_Timeout(:final duration) =>
          'Did not get a response in time ($duration)',
      };
}

@freezed
sealed class SendError with _$SendError implements FrbException {
  const SendError._();

  const factory SendError.pipeBroken({
    required String message,
  }) = SendError_PipeBroken;

  @override
  String toString() => switch (this) {
        SendError_PipeBroken(:final message) =>
          'Failed to send message (pipe broken): $message',
      };
}
