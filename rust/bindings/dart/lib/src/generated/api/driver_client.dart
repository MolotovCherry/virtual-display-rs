// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api.dart';
import '../frb_generated.dart';
import 'client.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'driver_client.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DriverClient>>
abstract class DriverClient implements RustOpaqueInterface {
  /// Add a new monitor.
  ///
  /// Returns an error if a monitor with this ID already exists, or if the
  /// monitor is invalid. A monitor is invalid if it has duplicate modes, or
  /// if any of its modes has duplicate refresh rates.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void add({required Monitor monitor});

  /// Add a mode to the monitor with the given ID.
  ///
  /// Returns an error if the monitor does not exist, or if the mode already
  /// exists on that monitor, or if the mode is invalid. A mode is invalid if
  /// it has duplicate refresh rates.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void addMode({required int id, required Mode mode});

  /// Connect to driver on pipe with default name.
  ///
  /// You can optionally specify the name of the named pipe to connect to. The
  /// default name is "virtualdisplaydriver"
  static Future<DriverClient> connect({String? pipeName}) =>
      RustLib.instance.api
          .crateApiDriverClientDriverClientConnect(pipeName: pipeName);

  /// Find the monitor with the given ID.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  Monitor? findMonitor({required int id});

  /// Get the closest available free ID.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  ///
  /// Note: Duplicate monitors are ignored when send to the Driver using
  /// [DriverClient.notify].
  int? newId({int? preferredId});

  /// Send the current client state to the driver.
  ///
  /// State changes of the client are not automatically sent to the driver.
  /// You must manually call this method to send changes to the driver.
  Future<void> notify();

  /// Write client state to the registry for current user.
  ///
  /// Next time the driver is started, it will load this state from the
  /// registry. This might be after a reboot or a driver restart.
  Future<void> persist();

  /// Returns a stream of continuous events from the driver.
  ///
  /// This stream will always reflect the real state of the driver, regardless
  /// of who changed its state. This means, if it is changed by another
  /// process, this stream will still be updated.
  Stream<List<Monitor>> receiveEvents();

  /// Manually synchronize with the driver.
  Future<List<Monitor>> refreshState();

  /// Remove monitors by id.
  ///
  /// Silently skips IDs that do not exist.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void remove({required List<int> ids});

  /// Remove all monitors.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  void removeAll();

  /// Remove a mode from the monitor with the given ID.
  ///
  /// Returns an error if the monitor does not exist. If the mode does not
  /// exist, it is silently skipped.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void removeMode({required int id, required (int, int) resolution});

  /// Replace an existing monitor. The monitor is identified by its ID.
  ///
  /// Throws [MonitorNotFoundError] if the monitor does not exist.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void replaceMonitor({required Monitor monitor});

  /// Set enabled state of all monitors with the given IDs.
  ///
  /// Silently skips incorrect IDs.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  void setEnabled({required List<int> ids, required bool enabled});

  /// Replace all monitors.
  ///
  /// Note: This does not affect the driver. Manually call
  /// [DriverClient.notify] to send these changes to the driver.
  void setMonitors({required List<Monitor> monitors});

  /// Get the current monitor state stored inside this client.
  ///
  /// Note: Client state might be stale. To synchronize with the driver,
  /// manually call [DriverClient.refreshState].
  List<Monitor> get state;
}

@freezed
sealed class AddModeError with _$AddModeError implements FrbException {
  const AddModeError._();

  const factory AddModeError.monitorNotFound({
    required int id,
  }) = AddModeError_MonitorNotFound;
  const factory AddModeError.modeExists({
    required int monitorId,
    required int width,
    required int height,
  }) = AddModeError_ModeExists;
  const factory AddModeError.refreshRateExists({
    required int monitorId,
    required int width,
    required int height,
    required int refreshRate,
  }) = AddModeError_RefreshRateExists;

  @override
  String toString() => switch (this) {
        AddModeError_MonitorNotFound(:final id) =>
          'Monitor with id $id not found',
        AddModeError_ModeExists(
          :final monitorId,
          :final width,
          :final height
        ) =>
          'Mode ${width}x$height already exists on monitor $monitorId',
        AddModeError_RefreshRateExists(
          :final monitorId,
          :final width,
          :final height,
          :final refreshRate
        ) =>
          'Refresh rate $refreshRate already exists on mode ${width}x$height on monitor $monitorId',
      };
}

@freezed
sealed class DuplicateError with _$DuplicateError implements FrbException {
  const DuplicateError._();

  const factory DuplicateError.monitor({
    required int id,
  }) = DuplicateError_Monitor;
  const factory DuplicateError.mode({
    required int monitorId,
    required int width,
    required int height,
  }) = DuplicateError_Mode;
  const factory DuplicateError.refreshRate({
    required int monitorId,
    required int width,
    required int height,
    required int refreshRate,
  }) = DuplicateError_RefreshRate;

  @override
  String toString() => switch (this) {
        DuplicateError_Monitor(:final id) =>
          'Monitor with id $id already exists',
        DuplicateError_Mode(:final monitorId, :final width, :final height) =>
          'Mode ${width}x$height already exists on monitor $monitorId',
        DuplicateError_RefreshRate(
          :final monitorId,
          :final width,
          :final height,
          :final refreshRate
        ) =>
          'Refresh rate $refreshRate already exists on mode ${width}x$height on monitor $monitorId',
      };
}

@freezed
sealed class InitError with _$InitError implements FrbException {
  const InitError._();

  const factory InitError.connect({
    required ConnectionError inner,
  }) = InitError_Connect;
  const factory InitError.requestState({
    required RequestError inner,
  }) = InitError_RequestState;

  @override
  String toString() => 'Failed to initialize DriverClient: $inner';
}

class MonitorNotFoundError implements FrbException {
  final int id;

  const MonitorNotFoundError({
    required this.id,
  });

  @override
  String toString() => 'Monitor with id $id not found';

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MonitorNotFoundError &&
          runtimeType == other.runtimeType &&
          id == other.id;
}
